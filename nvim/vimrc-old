" Launch config {{{
set nocompatible            " Makes it non-compatible with vi

if has ('nvim')
    " As nvim follows the XDG base directories convention (while vim itself
    " does not), you'll need to add a file to your $XDG_CONFIG_HOME directory
    " (usually '~/.config'). Create '~/.config/nvim/init.vim' with
    " these contents:
    "    set runtimepath^=~/.vim runtimepath+=~/.vim/after
    "    let &packpath = &runtimepath
    "    source ~/.vimrc
    "
    " UltiSnips has a problem until the neovim python plugin is installed.
    "
    "    pip3 install neovim
    "
    runtime! plugin/python_setup.vim
    " Disable neovim chaning cursor in insert vs command mode
    set guicursor=
endif

filetype off                " Filetype detection off
call pathogen#infect()      " Initialize pathogen for bundle installing
call pathogen#runtime_append_all_bundles() " use pathogen
filetype plugin indent on   " Filetype detection for plugins and indents
" }}}

" General Config {{{
set autochdir               " Always change to dir of current file
set modelines=1             " Check first and last line for vim mode commands
set history=10000           " Store ton of history (default 20)
set backspace=indent,eol,start " Normal backspace behaviour
set lazyredraw              " Don't redraw action is typed
set ttyfast                 " Fast terminal connection, better redrawing

" Set vim internal incoding as UTF8
"set encoding=utf-8

"Make semicolon into colon
map ; :

" let mapleader=","          " leader is comma
" }}}

" Colors and GUI {{{
" Set colors for normal text to white text on black background
hi Normal guifg=white guibg=black

" Must set terminal to 256 color mode for this colorscheme.
"
" Add the following lines to you $HOME/.bashrc
"       if [ "$TERM" == "xterm" ]; then
"           export TERM=xterm-256color
"       fi
"
" Add the following lines to $HOME/.zshrc_local
"
"if [ -e /usr/share/terminfo/x/xterm-256color ] ||
"  [ -e /lib/terminfo/x/xterm-256color ]; then
"    export TERM='xterm-256color'
"else
"    export TERM='xterm-color'
"fi
"
" See the link below for a more explicit howto.
" http://www.robmeerman.co.uk/unix/256colours

"if has("gui_running")
    "colorscheme mustang
"endif

"TODO: Figure out if there is a way to find if it is xterm-256color
set background=dark

let g:badwolf_darkgutter = 1    " Make gutter darker than background
let g:badwolf_tabline = 3       " Make tabline lighter than background
"colorscheme badwolf2            " Badwolf colorscheme
colorscheme synthwave

"set termguicolors
"colorscheme cyberpunk
"colorscheme silverhand
"let g:airline_theme='cyberpunk'
"let g:airline_theme='silverhand'

"colorscheme mustang

"colorscheme neuromancer
"let g:go_highlight_operators    = 1
"let g:go_highlight_functions    = 1
"let g:go_highlight_methods      = 1
"let g:go_highlight_types        = 1
"let g:go_highlight_fields       = 1
"let g:go_highlight_variable_declarations = 1
"let g:go_fmt_command            = "goimports"

syntax enable                   " Enable syntax highlighting

" Transparent background. Normal = Text, NonText = rest of screen
"hi Normal ctermbg=none
"hi NonText ctermbg=none
" }}}

" UI {{{
set number                  " Line numbers
"set relativenumber          " Number relative to current cursor postion
set numberwidth=6           " Good up to '99999 ' lines (inc. space after #s)
set wildmenu                " Auto completion for commands
set showmatch               " Show matching braces
"set matchtime=3             " Show matches for only this amount of time

set wrap                    " Wrap long lines
set showbreak="+++"         " Show at end of wrapped lines
set linebreak               " Wrap lines based on 'breakat' (default whitespace)

" Remove underline
hi CursorLine term=NONE cterm=NONE
set cursorline              " highlight current line
"highlight MatchParen ctermbg=4

" Toggle 80 column line
nnoremap <silent> <Leader>cc :call ToggleColorColumn()<CR>

set showtabline=2           " Always show tabline at the top
set hidden                  " Open new buffer with unsaved changes in current
"set nohidden                " Close tab mean remove buffer
set tabpagemax=15           " 15 max tabs

"set colorcolumn=+1          " Highlight column right after 'textwidth'
set showmode                " Show the mode the editor is in
set autoread                " Watch for file changes
"set autowrite               " Autosave on buffer switch
set noerrorbells            " No error bells
set novisualbell            " No blinking errors
set shortmess=aOstT         " Short messages (to avoid 'press a key' prompt)
set splitright              " Vertical split to the right, not left
set splitbelow              " Horizontal split to the bottom, not top
set winminheight=0          " Window can be 0 lines high
set title                   " Change window title

set list                    " List certain characters
"set listchars=tab:▸\,trail:·,extends:»,precedes:«,nbsp:%,eol:↲ "utf-8
set listchars=tab:>-,trail:.,extends:>,precedes:<,nbsp:%
"             |      |       |         |          |
"             |      |       |         |          +-- non-breakable space that
"             |      |       |         |              prevents automatic line
"             |      |       |         |              breaks at that position
"             |      |       |         + character to show line goes off
"             |      |       |           screen to the right (when 'wrap'
"             |      |       |           is off)
"             |      |       +-- character to show line goes off screen to
"             |      |           right (when 'wrap' is off)
"             |      +-- trailing spaces in line
"             +-- tab character anywhere in line


" set colorcolumn=80        " Highlight specific column
if version >= 700           " Use english for spell check, but off by default
    set spl=en spell
    set nospell
endif

if has("eval")
function! SL(function)
  if exists('*'.a:function)
    return call(a:function,[])
  else
    return ''
  endif
endfunction
endif

"set statusline=[%n]\ %<%.99f\ %h%w%m%r%{SL('CapsLockStatusline')}%y%{SL('fugitive#statusline')}%#ErrorMsg#%{SL('SyntasticStatuslineFlag')}%*%=%-14.(%l,%c%V%)\ %P
"               +- buffer number

set statusline=%F%m%r%h%w[%L][%{&ff}]%y[%p%%][%04l,%04v]
"              | | | | |  |   |      |  |     |    |
"              | | | | |  |   |      |  |     |    +-- current column
"              | | | | |  |   |      |  |     +-- current line
"              | | | | |  |   |      |  +-- current % into file
"              | | | | |  |   |      +-- current syntax in square brackets
"              | | | | |  |   +-- current fileformat
"              | | | | |  +-- number of lines
"              | | | | +-- preview flag in square brackets
"              | | | +-- help flag in square brackets
"              | | +-- readonly flag in square brackets
"              | +-- modified flag in square brackets
"              +-- full path to file in the buffer

set statusline+=%{fugitive#statusline()}            " Show git statusline

set statusline+=%#StatuslineErrorMsg#               " Set color for syntastic
set statusline+=%{SyntasticStatuslineFlag()}        " Display syntastic flag
set statusline+=%*                                  " Reset color

set laststatus=2            " Always display status line

if has('cmdline_info')
    set ruler               " Show line and column number in cmdline
    "set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " A ruler on steroids
    set showcmd             " Show partial command
endif
" }}}

" Formatting {{{
set textwidth=79            " Line break after 79 characters
set formatoptions-=t        " No hard line wrap
set formatoptions-=2        " No paragraph indenting
set formatoptions+=qrn1jl
"                  ||||||
"                  |||||+-- long lines no broken in insert mode
"                  ||||+-- remove comment leader when joining lines
"                  |||+-- don't break line on one letter word if possible
"                  ||+-- recognize numbered lists, autoindent must be on
"                  |+-- automatically insert comment leader after hitting
"                  |    enter in Insert
"                  +-- alow formatting comments with "gq"
set cinoptions=l1           " indent c switch statements in a sane way
" }}}

" Spaces & Tabs {{{
set tabstop=4 shiftwidth=4  " Tab is 4 spaces
set shiftround              " Round '>' shifting to nearest tabstop
set expandtab               " Expand tabs to spaces
set smarttab                " Tabs before text insert 'shiftwidth' spaces
set autoindent              " Auto indent always on
set smartindent             " Intelligent code indenting

" Trim trailing whitespaces (function keeps search intact)
"map <Leader>trim :%s/\s\+$//<CR>:w<CR>
map <leader>trim :call StripTrailingWhitespaces()<CR>:w<CR>
" }}}

" Mouse {{{
set mouse=a                 " Mouse enabled

" Commands to disable mouse for xterm copy and paste
nnoremap <silent> md :set mouse=r<CR>:set number!<CR>
nnoremap <silent> me :set mouse=a<CR>:set number!<CR>
" }}}

" Searching {{{
set incsearch               " Find as you type search
set hlsearch                " Highlight search matches

set ignorecase              " Ignore case in search
set smartcase               " But case sensitive if upper case present

" Ignore things!
"set wildignore+=.hg,.git.svc                        " Version control
set wildignore+=.aux,*.out,*.toc                    " LaTex intermediate files
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg      " Binaries
set wildignore+=*.o,*.obj,*.exe,*.dll,*.manifest    " Compiled object files
set wildignore+=*.spl                               " Compiled spelling lists
set wildignore+=*.sw?                               " Vim swap files
set wildignore+=*.DS_Store                          " OSX dir files
set wildignore+=*.pyc                               " Python byte code
set wildignore+=*.orig                              " Merge resolution files
set wildignore+=*.bak                               " Backup files
set wildignore+=*~
set wildmode=list:longest,full " Give list for auto complete

" Press F9 to turn off highlighting and clean any messages alreade displayed
"nnoremap <silent> <Space> :nohlsearch<Bar>:echo<CR>
"nnoremap <silent> <S-Space> :nohlsearch<Bar>:echo<CR>
nnoremap <silent> <F9> :nohlsearch<Bar>:echo<CR>
" }}}

" Movement {{{
set scroll=10               " Scroll only 10 lines with Ctrl-D and Ctrl-U
set scrolloff=5             " Minimum lines above and below cursor
set sidescrolloff=10        " Keep 10 columns on the side
set virtualedit+=onemore    " Allow for cursor beyond last char of line
set virtualedit+=block      " Allow for cursor beyond last char of line in visual block mode

" Wrapped lines goes up/down to next row rather than next line in buf
noremap j gj
noremap k gk
noremap gj j
noremap gk k

" highlight last inserted text
nnoremap gV `[v`]

" move to beginning/end of line
nnoremap B ^
nnoremap E $
" }}}

" UltiSnips {{{
" Snips author tag
let g:snips_author = 'Quillan Kaseman'

let g:UltiSnipsEditSplit = "vertical"
let g:UltiSnipsListSnippets = "<c-l>"
let g:UltiSnipsExpandTrigger="<tab>"
"let g:UltiSnipsJumpForwardTrigger="<tab>"
"let g:UltiSnipsJumpBackwardTrigger="<s-tab>"
" }}}

" Folding {{{
set foldenable              " Enable folding
"set foldmethod=manual       " Manual folding
set foldmethod=indent       " Fold based on indent level
"set foldmethod=syntax       " Fold on syntax
set foldlevelstart=99       " Open most folds by default
set foldnestmax=10          " Max 10 folds in folds

" Create folds by pressing highlighting text and pressing F9
" Can then open/close with F9
"inoremap <F9> <C-O>za
"nnoremap <F9> za
"onoremap <F9> <C-C>za
"vnoremap <F9> zf

" Open and close folds with space
nnoremap <space> za
vnoremap <space> za

" Fold outer level automatically
nnoremap zr :%foldc <CR>
vnoremap zr :%foldc <CR>

" Automatically fold top level
":autocmd BufWinEnter * silent! :%foldc
" }}}

" Copy/Cut/Paste {{{
" Make 'Y' behave like 'D' and 'C'
nnoremap Y y$

" Set F2 to toggel paste mode in normal in insert mode
nnoremap <F2> :set invpaste paste?<CR>
set pastetoggle=<F2>

" Keep paste buffer around after pasting it once
xnoremap p pgvy

" Enter past mode, paste from system clipboard, and exit paste mode
" + CLIBOARD, * is PRIMARY
"   |              |
"   |              +-- things you select with mouse and paste with middle mouse
"   |                  button
"   +-- proper clipboard
noremap <leader>p :silent! set paste<CR>"+p:set nopaste<CR>
noremap <leader>P :silent! set paste<CR>"*p:set nopaste<CR>

" Paste/Copy/Cut using system clipboard
" TODO: Add if OSX, use SystemCopy()
noremap <leader>y  "+y
noremap <leader>yy "+yy
noremap <leader>Y  "+y$
noremap <leader>d  "+d
noremap <leader>dd "+dd
noremap <leader>D  "+D
" }}}

" Backups {{{
" Backup into an easy to find directory
set backupdir=$HOME/.vim_backups
set directory=$HOME/.vim_backups//,$TMP//,$TEMP// " Use full path to file as swap name

" Make backup dir if doesn't exist
if !isdirectory(expand(&backupdir))
    call mkdir(expand(&backupdir), "p")
endif
" }}}

" Persistent Undo {{{
" Make undo persistant after file closed
set undodir=$HOME/.vim_undodir
set undofile
set undoreload=10000        " Save entire buffer for undo on reload if less than this size

" Make undo dir if doesn't exist
if !isdirectory(expand(&undodir))
    call mkdir(expand(&undodir), "p")
endif
" }}}

" Convenience Mappings {{{
" Create blank newlines and stay in Normal mode
nnoremap <silent> zj o<Esc>
nnoremap <silent> zk O<Esc>

" No more help key, instead check if file changed outside VIM
noremap <F1> :checktime<cr>
inoremap <F1> <esc>:checktime<cr>

" Split line (sister to [J]oin lines)
" The normal use of S is covered by cc, so don't worry about shadowing it.
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w

" Allow saving of files as sudo when vim wasn't started with sudo
" (throw away the stdin part of tee)
cmap w!! w !sudo tee > /dev/null %

" Cool svn blame on highlight
vmap bl :<C-U>!svn blame <C-R>=expand("%:p") <CR> \| sed -n <C-R>=line("'<") <CR>,<C-R>=line("'>") <CR>p <CR>

" Insert new lines without being in insert mode
" map <Enter> o<Esc>
" map <S-Enter> O<Esc>

" Save session so windows open next time
nnoremap <leader>s :mksession<CR>

" Open make output in a quick fix window
map <Leader>m :make \| copen<CR>

" Swap split positions on write and read (horizontal to vertical)
nnoremap <silent><Leader>s <C-w>L

" toggel gundo
nnoremap <leader>u :GundoToggle<CR>
" }}}

" NERDTree {{{
" NERDTree stuff
" NERDTreePlugin open current file
map <silent> <F4> :NERDTreeToggle .<CR>
let NERDTreeQuitOnOpen=1
let NERDTreeIgnore=['\~$', '^\.git', '\.swp$', '\.DS_Store$']
let NERDTreeShowHidden=1
let NERDChristmasTree = 1 " Colorful tree
let NERDTreeDirArrows = 0 " Use '+/~' for directories rather than arrows
" }}}

" Syntastic {{{
" Set syntax checkers for languages
let g:syntastic_python_checkers = ['flake8']

"Can't use pylint because newspeak needs a different version of asteroid
"let g:syntastic_python_checkers = ['pylint']

" Allow single character variable names and two character argument names
let g:syntastic_python_flake8_args = "--ignore=E203,W391"
let g:syntastic_python_pylint_args = "--disable=no-self-use --variable-rgx=\"[a-z_][a-z0-9_]{0,30}$\" --argument-rgx=\"[a-z_][a-z0-9_]{1,30}$\""

let g:syntastic_mode_map={'mode': 'passive'}    " User triggers syntax checking

let g:syntastic_always_populate_loc_list = 1    " Always populate error list
let g:syntastic_auto_loc_list = 0               " Don't autodisplay error list
let g:syntastic_loc_list_height = 5             " 5 lines for errors
let g:syntastic_check_on_open = 1               " Check for errors on open
let g:syntastic_check_on_wq = 0                 " Don't check on write close

" Better :sign interface symbols
let g:syntastic_error_symbol = '✗'              " Nicer error symbol
let g:syntastic_warning_symbol = '!'            " Set warning symbol

" Open loc list
" Look into grabbing https://github.com/milkypostman/vim-togglelist, or doing
" own version of toggle
nnoremap <silent> <F8> :SyntasticCheck<CR> :Error<CR>
nnoremap <silent> <F7> :lclose<CR>

" }}}

" Tags {{{
" Move split tag into a new tab
nnoremap <silent><Leader>t <C-w>T

" Taglist plugin support
nnoremap <silent> <F11> :TlistToggle<CR>

" Generate taglist for Taglist plugin
" TODO: Figure out why this doesn't work on mac
nnoremap <F12> :TlistAddFiles . *.py *.c *.h<CR>:!ctags -R --append ./ <CR><CR>
"nnoremap <F12> :TlistAddFiles . *.py *.c *.h<CR>:!ctags -R --append ../ <CR><CR>
"nnoremap <F12> :TlistAddFilesRecursive . *.py *.c *.h<CR>

" Look up the tree for tags
"set tags=./tags,tags;
" let &tags = findfile("tags", "**;")

" Alt+] opens tag in new vertical split
map <A-]> :vsp <CR>:exec("tag ".expand("<cword>"))<CR>
"}}}

" Buffer Movement {{{
map <silent> <leader>mw :call MarkWindowSwap()<CR>
map <silent> <leader>mmw :call DoWindowSwap()<CR>
"
" TODO: Make tab switching faster/more intuitive
map <silent><C-A-Left> :execute TabLeft()<CR>
map <silent><C-A-Right> :execute TabRight()<CR>
"}}}

" AutoGroups {{{
" http://wwwcdf.pd.infn.it/vim/autocmd.html
" augroup so only run once
augroup configgroup
    au!
    " ruby standard 2 spaces, always
    au BufRead,BufNewFile *.rb,*.rhtml setlocal shiftwidth=2
    au BufRead,BufNewFile *.rb,*.rhtml setlocal softtabstop=2

    " On reading a new buffer, run syntax check
    au BufRead * :SyntasticCheck

    " Remember everything (position, folds, etc)
    "au BufWinLeave * execute ":silent! mkview"
    "Ignore errors for BufWinEnter
    "au BufWinEnter * execute ":silent! loadview"
    au BufWinLeave ?*  mkview 1
    au BufWinEnter ?* ":silent! loadview 1"

    au vimenter * if !argc() | NERDTree | endif " If no file specified when starting vim, open NERDTree

    " Highlight trailing spaces as error when entering a window (a split is a
    " new window even if viewing same buffer).
    :au BufWinEnter,WinEnter * silent! match ErrorMsg /\s\+$/

    " Color column on when making a new buffer window.
    :au BufWinEnter * silent! :call ColorColumnOn()
augroup END

"augroup trailing
    ""Only show training in non-insert mode
    "au!
    "au InsertEnter * :set listchars-=trail:.
    "au InsertLeave * :set listchars+=trail:.
"augroup END

"augroup CursorLineOnlyInActiveWindow
    "autocmd!
    "autocmd VimEnter,WinEnter,BufWinEnter * hi CursorLine term=NONE cterm=NONE " Remove underline
    "autocmd VimEnter,WinEnter,BufWinEnter * setlocal cursorline              " highlight current line
    "autocmd WinLeave * setlocal nocursorline
"augroup END
"
"}}}

" Custom Functions {{{
" 'function!' means overwrite existing function on reload

" Copy text to system clipboard on OSX
function! g:SystemCopy() " {{{
    let old_z = @z
    normal! gv"zy
    call system('pbcopy', @z)
    let @z = old_z
endfunction " }}}

" Pulse current line
" s: is so it only pulses in current buffer
function! Pulse() " {{{
    redir => old_hi
        silent execute 'hi CursorLine'
    redir END
    let old_hi = split(old_hi, '\n')[0]
    let old_hi = substitute(old_hi, 'xxx', '', '')

    let steps = 8
    let width = 1
    let start = width
    let end = steps * width
    let color = 233

    for i in range(start, end, width)
        execute "hi CursorLine ctermbg=" . (color + i)
        redraw
        sleep 12m
    endfor
    for i in range(end, start, -1 * width)
        execute "hi CursorLine ctermbg=" . (color + i)
        redraw
        sleep 12m
    endfor

    execute 'hi ' . old_hi
endfunction " }}}
command! -nargs=0 Pulse call Pulse()

" Make colored column at 80 chars
function! ColorColumnOn() " {{{
    if exists("+colorcolumn")
        setlocal colorcolumn=80
    else
        highlight OverLength ctermbg=darkred ctermfg=white guibg=#FFD9D9
        match OverLength /\%>80v.\+/
    endif
endfunction "}}}
command! -nargs=0 ColorColumnOn call ColorColumnOn()

" Toggle colored column at 80 chars
function! ToggleColorColumn() " {{{
    " Colorcolum only exists in 7.3+
    if exists('+colorcolumn')
        if empty(&colorcolumn)
            setlocal colorcolumn=80
        else
            setlocal colorcolumn=
        endif
    else
        highlight OverLength ctermbg=darkred ctermfg=white guibg=#FFD9D9
        match OverLength /\%>80v.\+/
    endif
endfunction " }}}
command! -nargs=0 ToggleColorColumn call ToggleColorColumn()

" Shift tabs around
function! TabLeft() " {{{
   let tab_number = tabpagenr() - 1
   if tab_number == 0
      execute "tabm" tabpagenr('$') - 1
   else
      execute "tabm" tab_number - 1
   endif
endfunction " }}}
command! -nargs=0 TabLeft call TabLeft()

function! TabRight() " {{{
   let tab_number = tabpagenr() - 1
   let last_tab_number = tabpagenr('$') - 1
   if tab_number == last_tab_number
      execute "tabm" 0
   else
      execute "tabm" tab_number + 1
   endif
endfunction " }}}
command! -nargs=0 TabRight call TabRight()

function! MarkWindowSwap() " {{{
    " Mark window to swap
    let g:markedWinNum = winnr()
endfunction " }}}
command! -nargs=0 MarkWindowSwap call MarkWindowSwap()

function! DoWindowSwap() " {{{
    "Mark destination
    let curNum = winnr()
    let curBuf = bufnr( "%" )
    exe g:markedWinNum . "wincmd w"
    "Switch to source and shuffle dest->source
    let markedBuf = bufnr( "%" )
    "Hide and open so that we aren't prompted and keep history
    exe 'hide buf' curBuf
    "Switch to dest and shuffle source->dest
    exe curNum . "wincmd w"
    "Hide and open so that we aren't prompted and keep history
    exe 'hide buf' markedBuf
endfunction " }}}
command! -nargs=0 DoWindowSwap call DoWindowSwap()
"}}}

" Edit vimrc/zshrc {{{
nnoremap <leader>ev :vsp $MYVIMRC<CR>
nnoremap <leader>ez :vsp $HOME/.zshrc<CR>
nnoremap <leader>sv :source $MYVIMRC<CR>
" }}}

" Load local vimrc {{{
" Do any local configurations if they exist
if filereadable($HOME. "/.vimrc_local")
    :source ${HOME}/.vimrc_local
endif
"}}}

" vim:foldmethod=marker:foldlevel=0
